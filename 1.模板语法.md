# Vue3 模板语法

## 一、Mustache 双大括号语法

```html
<!-- mustache基本使用 -->
<div>{{ message }}</div>
<!-- JavaScript表达式 -->
<div>{{ counter * 2 }}</div>
<div>{{ message.split(" ").reverse().join(" ") }}</div>
<!-- 调用一个methods中的函数 -->
<div>{{ reverse(message) }}</div>
```

## 二、v-once

1. v-once 用于指定元素或者组件只渲染一次：

   - 当数据发生变化时，元素或者组件以及其所有的子元素将视为静态内容并且跳过
   - 该指令可以用于性能优化

2. 如果是子节点，也是只会渲染一次

```html
<div v-once>这个将不会改变: {{ msg }}</div>
```

## 三、v-test

用于更新元素的 textContent

```html
<span v-text="msg"></span>
<!-- 等价于 -->
<span>{{ msg }}</span>
```

## 四、v-html

默认情况下，如果我们展示的内容本身就是 html，那么 vue 并不会对其进行特殊的解析。
如果我们希望这个内容被 vue 解析出来，那么可以使用 v-html 来展示。
**注意：**
**1. 内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译**
**2. 在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 XSS 攻击。只在可信内容上使用 v-html，永不用在用户提交的内容上。**

```html
<div v-html="'<h1>Hello World</h1>'"></div>
```

## 五、v-pre

跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。

```html
<span v-pre>{{ this will not be compiled }}</span>
```

## 六、v-cloak

这个指令保持在元素上直到关联组件实例结束编译。和 CSS 规则如 `[v-cloak] { display: none }` 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到组件实例准备完毕。

```css
[v-cloak] {
  display: none;
}
```

```html
<div v-cloak>{{ message }}</div>
```

`<div>` 不会显示，直到编译结束。

## 七、v-bind 的绑定属性

- 缩写：`：`或 `.` (当使用 `.prop` 修饰符时)
- 修饰符：
  - `.camel` - 将 kebab-case attribute 名转换为 camelCase。
  - `.prop` - 将一个绑定强制设置为一个 DOM property。3.2+
  - `.attr` - 将一个绑定强制设置为一个 DOM attribute。3.2+
- 用法：
  - 动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。
  - 在绑定 `class` 或 `style` attribute 时，支持其它类型的值，如数组或对象。
  - 在绑定 `prop` 时，`prop` 必须在子组件中声明。可以用修饰符指定不同的绑定类型。
  - 没有参数时，可以绑定到一个包含键值对的对象。注意此时 `class` 和 `style` 绑定不支持数组和对象。

```html
<!-- 绑定 attribute -->
<img v-bind:src="imageSrc" />

<!-- 动态 attribute 名 -->
<button v-bind:[key]="value"></button>

<!-- 缩写 -->
<img :src="imageSrc" />

<!-- 动态 attribute 名缩写 -->
<button :[key]="value"></button>

<!-- 内联字符串拼接 -->
<img :src="'/path/to/images/' + fileName" />

<!-- class 绑定 -->
<div :class="{ red: isRed }"></div>
<div :class="[classA, classB]"></div>
<div :class="[classA, { classB: isB, classC: isC }]"></div>

<!-- style 绑定 -->
<div :style="{ fontSize: size + 'px' }"></div>
<div :style="[styleObjectA, styleObjectB]"></div>

<!-- 绑定一个全是 attribute 的对象 -->
<div v-bind="{ id: someProp, 'other-attr': otherProp }"></div>

<!-- prop 绑定。"prop" 必须在 my-component 声明 -->
<my-component :prop="someThing"></my-component>

<!-- 将父组件的 props 一起传给子组件 -->
<child-component v-bind="$props"></child-component>

<!-- XLink -->
<svg><a :xlink:special="foo"></a></svg>
```

当在一个元素上设置一个绑定的时候，Vue 会默认通过 in 操作检测该元素是否有一个被定义为 property 的 key。如果该 property 被定义了，Vue 会将这个值设置为一个 DOM property 而不是 attribute。大多数情况下，这样工作是正常的，但你也可以通过 .prop 或 .attr 修饰符显性地覆写这个行为。有的时候这是必要的，尤其是基于自定义元素的工作。

## 八、v-on

- 缩写：@
- 修饰符：
  - `.stop` - 调用 event.stopPropagation()。
  - `.prevent` - 调用 event.preventDefault()。
  - `.capture` - 添加事件侦听器时使用 capture 模式。
  - `.self` - 只当事件是从侦听器绑定的元素本身触发时才触发回调。
  - `.{keyAlias}` - 仅当事件是从特定键触发时才触发回调。
  - `.once` - 只触发一次回调。
  - `.left` - 只当点击鼠标左键时触发。
  - `.right` - 只当点击鼠标右键时触发。
  - `.middle` - 只当点击鼠标中键时触发。
  - `.passive` - `{ passive: true }` 模式添加侦听器
- 用法：
  - 绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。
  - 用在普通元素上时，只能监听原生 DOM 事件。用在自定义元素组件上时，也可以监听子组件触发的自定义事件。
  - 监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 `$event` property：`v-on:click="handle('ok', $event)"`。
  - `v-on` 同样支持不带参数绑定一个事件/监听器键值对的对象。注意当使用对象语法时，是不支持任何修饰器的。

```html
<!-- 方法处理器 -->
<button v-on:click="doThis"></button>

<!-- 动态事件 -->
<button v-on:[event]="doThis"></button>

<!-- 内联语句 -->
<button v-on:click="doThat('hello', $event)"></button>

<!-- 缩写 -->
<button @click="doThis"></button>

<!-- 动态事件缩写 -->
<button @[event]="doThis"></button>

<!-- 停止冒泡 -->
<button @click.stop="doThis"></button>

<!-- 阻止默认行为 -->
<button @click.prevent="doThis"></button>

<!-- 阻止默认行为，没有表达式 -->
<form @submit.prevent></form>

<!-- 串联修饰符 -->
<button @click.stop.prevent="doThis"></button>

<!-- 键修饰符，键别名 -->
<input @keyup.enter="onEnter" />

<!-- 点击回调只会触发一次 -->
<button v-on:click.once="doThis"></button>

<!-- 对象语法 -->
<button v-on="{ mousedown: doThis, mouseup: doThat }"></button>
```

在子组件上监听自定义事件 (当子组件触发“my-event”时将调用事件处理器)：

```html
<my-component @my-event="handleThis"></my-component>

<!-- 内联语句 -->
<my-component @my-event="handleThis(123, $event)"></my-component>
```

## 九、条件渲染（v-if、v-else、v-else-if、v-show）

**1. v-if、v-else、v-else-if**

- 根据表达式的真假值来有条件地渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 `<template>`，将提取它的内容作为条件块。
- 当条件变化时该指令触发过渡效果。
- 当和 v-for 一起使用时，v-if 的优先级比 v-for 更高。

```html
<div v-if="type === 'A'">A</div>
<div v-else-if="type === 'B'">B</div>
<div v-else-if="type === 'C'">C</div>
<div v-else>Not A/B/C</div>
```

**2. v-show**
根据表达式的真假值，切换元素的 `display` CSS property。

```html
<div v-show="isShow">show</div>
```

**3. v-show 和 v-if 的区别**

- 首先，在用法上的区别：
  - v-show 不支持 template
  - v-show 不可以和 v-else 一起使用
- 其次，本质的区别：
  - v-show 元素无论在是否需要显示在浏览器上，它的 DOM 实际上都是有渲染的，只是通过 css 的 display 属性来进行切换
  - v-if 当条件为 false 时，其对应的原生压根不会被渲染到 DOM 中
- 开发中如何进行选择
  - 如果我们的原生需要在显示和隐藏之间频繁的切换，那么使用 v-show
  - 如果不会频繁的发生切换，那么使用 v-if

## 十、v-for

v-for 的基本格式是 "item in 数组"：

- 数组通常是来自 data 或者 prop，也可以是其他方式
- item 是我们给每项元素起的一个别名，这个别名可以自定来定义

```html
<ul>
  <li v-for="item in movies">{{ item }}</li>
</ul>
```

在遍历一个数组的时候会经常需要拿到数组的索引：

- 如果我们需要索引，可以使用格式： "(item, index) in 数组"
- 注意顺序：数组元素项 item 是在前面的，索引项 index 是在后面的

```html
<ul>
  <li v-for="(item, index) in movies">{{ item }} - {{ index }}</li>
</ul>
```

v-for 也支持遍历对象，并且支持有一二三个参数：

- 一个参数： "value in object"
- 二个参数： "(value, key) in object"
- 三个参数： "(value, key, index) in object"

```html
<ul>
  <li v-for="(value, key, index) in myObject">{{ index }}. {{ key }}: {{ value }}</li>
</ul>
```

v-for 同时也支持数字的遍历

- 每一个 item 都是一个数字

```html
<ul>
  <li v-for="item in 10">{{ item }}</li>
</ul>
```

类似于 v-if，可以使用 template 元素来循环渲染一段包含多个元素的内容

```html
<ul>
  <template v-for="(value, key) in myObject">
    <li>{{ key }}</li>
    <li>{{ value }}</li>
  </template>
</ul>
```

**v-for 中的 key 是什么作用**

- key 属性主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes；
- 如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法；
- 而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除/销毁 key 不存在的元素.

## 十一、v-memo `3.2+`

记住一个模板的子树。元素和组件上都可以使用。该指令接收一个固定长度的数组作为依赖值进行记忆比对。如果数组中的每个值都和上次渲染的时候相同，则整个该子树的更新会被跳过。例如：

```html
<div v-memo="[valueA, valueB]">...</div>
```

当组件重新渲染的时候，如果 `valueA` 与 `valueB` 都维持不变，那么对这个 `<div>` 以及它的所有子节点的更新都将被跳过。事实上，即使是虚拟 DOM 的 VNode 创建也将被跳过，因为子树的记忆副本可以被重用。

正确地声明记忆数组是很重要的，否则某些事实上需要被应用的更新也可能会被跳过。带有空依赖数组的 `v-memo` (`v-memo="[]"`) 在功能上等效于 `v-once`。

`v-memo` 也可以用于组件，在子组件的更新检查未进行优化的某些极端场景下，手动防止不必要的更新。但是，重申一遍，开发者有责任指定正确的依赖数组，以避免必要的更新被跳过。

**注：** 在 `v-for` 中使用 `v-memo` 时，确保它们被用在了同一个元素上。 `v-memo` 在 `v-for` 内部是无效的。
